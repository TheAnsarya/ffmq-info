"""
Extract all 83 enemy sprites using discovered sprite pointer data.

Uses enemy_sprite_defs.json generated by extract_enemy_pointers.py to
extract all enemy sprites with correct offsets, sizes, and palettes.
"""

import os
import sys
import json
from pathlib import Path
from typing import List, Dict

sys.path.insert(0, str(Path(__file__).parent.parent))

from extraction.extract_sprites import SpriteExtractor, SpriteDefinition


def load_enemy_sprite_definitions(json_path: str) -> List[SpriteDefinition]:
    """Load sprite definitions from JSON."""
    with open(json_path) as f:
        data = json.load(f)

    sprite_defs = []
    for sprite in data['sprites']:
        # Convert hex string to int
        tile_offset = int(sprite['tile_offset'], 16)

        sprite_def = SpriteDefinition(
            name=sprite['name'],
            tile_offset=tile_offset,
            num_tiles=sprite['num_tiles'],
            width_tiles=sprite['width_tiles'],
            height_tiles=sprite['height_tiles'],
            palette_index=sprite['palette_index'],
            format=sprite['format'],
            category=sprite['category'],
            frames=[],  # No animation frames for enemies
            notes=sprite['notes']
        )
        sprite_defs.append(sprite_def)

    return sprite_defs


def load_enemy_names() -> Dict[int, str]:
    """Load enemy names from enemy data."""
    enemies_path = Path("data/extracted/enemies/enemies.json")
    if not enemies_path.exists():
        return {}

    with open(enemies_path) as f:
        data = json.load(f)
        return {e['id']: e['name'] for e in data['enemies']}


def create_enemy_sprite_mapping(sprite_defs: List[SpriteDefinition]) -> Dict:
    """
    Create mapping of enemy IDs to sprite definitions.

    Returns dict with:
    - sprite_def: The SpriteDefinition to use
    - is_shared: Whether this sprite is shared with other enemies
    - primary_enemy: The primary enemy ID for this sprite
    """
    # Load sprite metadata to get enemy_ids
    with open("data/extracted/sprites/enemy_sprite_defs.json") as f:
        metadata = json.load(f)

    enemy_to_sprite = {}

    for i, sprite_data in enumerate(metadata['sprites']):
        sprite_def = sprite_defs[i]
        enemy_ids = sprite_data['enemy_ids']
        primary_id = enemy_ids[0]
        is_shared = len(enemy_ids) > 1

        for enemy_id in enemy_ids:
            enemy_to_sprite[enemy_id] = {
                'sprite_def': sprite_def,
                'is_shared': is_shared,
                'primary_enemy': primary_id,
                'shared_with': enemy_ids if is_shared else None
            }

    return enemy_to_sprite


def main():
    """Extract all enemy sprites."""
    print("=" * 80)
    print("FFMQ Complete Enemy Sprite Extraction")
    print("=" * 80)
    print()

    rom_path = "roms/Final Fantasy - Mystic Quest (U) (V1.1).sfc"

    # Load sprite definitions
    sprite_defs_path = "data/extracted/sprites/enemy_sprite_defs.json"
    print(f"Loading sprite definitions: {sprite_defs_path}")
    sprite_defs = load_enemy_sprite_definitions(sprite_defs_path)
    print(f"✓ Loaded {len(sprite_defs)} unique sprite definitions")

    # Load enemy names
    print("\nLoading enemy data...")
    enemy_names = load_enemy_names()
    print(f"✓ Loaded {len(enemy_names)} enemy names")

    # Create enemy→sprite mapping
    print("\nCreating enemy-to-sprite mapping...")
    enemy_mapping = create_enemy_sprite_mapping(sprite_defs)
    print(f"✓ Mapped {len(enemy_mapping)} enemies to sprites")

    # Initialize extractor
    print(f"\nLoading ROM: {rom_path}")
    extractor = SpriteExtractor(rom_path)
    print("✓ ROM loaded")

    # Load palettes
    print("\nLoading palettes from Bank 05...")
    extractor.load_palettes(16)

    # Extract each enemy
    print("\n" + "=" * 80)
    print("Extracting Enemy Sprites")
    print("=" * 80)
    print()

    extraction_summary = {
        'total': len(enemy_mapping),
        'unique': len(sprite_defs),
        'shared': 0,
        'errors': []
    }

    for enemy_id in range(83):
        if enemy_id not in enemy_mapping:
            print(f"⚠ Enemy {enemy_id}: No sprite mapping found")
            extraction_summary['errors'].append(f"Enemy {enemy_id}: No mapping")
            continue

        mapping = enemy_mapping[enemy_id]
        sprite_def = mapping['sprite_def']
        enemy_name = enemy_names.get(enemy_id, f"Enemy_{enemy_id:02d}")

        # Create enemy-specific sprite def
        enemy_sprite_def = SpriteDefinition(
            name=f"enemy_{enemy_id:02d}_{sprite_def.name}",
            tile_offset=sprite_def.tile_offset,
            num_tiles=sprite_def.num_tiles,
            width_tiles=sprite_def.width_tiles,
            height_tiles=sprite_def.height_tiles,
            palette_index=sprite_def.palette_index,
            format=sprite_def.format,
            category="enemy",
            frames=[],
            notes=f"{enemy_name} (ID {enemy_id})"
        )

        # Print extraction status
        shared_info = ""
        if mapping['is_shared']:
            extraction_summary['shared'] += 1
            if enemy_id != mapping['primary_enemy']:
                primary_name = enemy_names.get(
                    mapping['primary_enemy'], f"Enemy_{mapping['primary_enemy']:02d}")
                shared_info = f" → Reuses sprite from {primary_name}"

        print(f"[{enemy_id:2d}] {enemy_name:<20} "
              f"({sprite_def.width_tiles}×{sprite_def.height_tiles} tiles){shared_info}")

        try:
            # Extract sprite (only save unique ones to avoid duplicates)
            if enemy_id == mapping['primary_enemy']:
                # This is the primary sprite - extract and save
                frames = extractor.extract_animation_frames(enemy_sprite_def)

                # Save sprite
                category_dir = extractor.output_dir / "enemies"
                category_dir.mkdir(exist_ok=True)

                sprite_path = category_dir / f"{enemy_sprite_def.name}.png"
                if frames:
                    frames[0].save(sprite_path)

                # Export metadata
                meta_path = category_dir / f"{enemy_sprite_def.name}_meta.json"
                extractor.export_sprite_metadata(enemy_sprite_def, meta_path)

        except Exception as e:
            print(f"  ✗ Error: {e}")
            extraction_summary['errors'].append(f"Enemy {enemy_id} ({enemy_name}): {e}")

    # Print summary
    print()
    print("=" * 80)
    print("Extraction Summary")
    print("=" * 80)
    print(f"Total Enemies: {extraction_summary['total']}")
    print(f"Unique Sprites: {extraction_summary['unique']}")
    print(f"Shared Sprites: {extraction_summary['shared']} enemies reuse graphics")
    print(f"Errors: {len(extraction_summary['errors'])}")

    if extraction_summary['errors']:
        print("\nErrors encountered:")
        for error in extraction_summary['errors']:
            print(f"  - {error}")

    print()
    print("✓ Enemy sprite extraction complete!")
    print()
    print("Next Steps:")
    print("  1. Review extracted sprites in data/extracted/sprites/enemies/")
    print("  2. Run create_sprite_catalog.py to generate visual catalog")
    print("  3. Verify sprites against in-game screenshots")
    print("  4. Adjust palette assignments if colors are incorrect")
    print()

    return 0


if __name__ == '__main__':
    sys.exit(main())
