#!/usr/bin/env python3
"""
Graphics ASM Generator
Generates asar-compatible assembly include files for rebuilt graphics.

This tool reads the import summary and creates .asm files that include
all rebuilt graphics at their correct ROM addresses, enabling automatic
integration with the asar build system.

Features:
- Auto-generate incbin statements for all rebuilt graphics
- Organize by category (sprites, palettes, tiles)
- Validate ROM addresses
- Generate build dependencies
- Create master include file

Usage:
	python generate_graphics_asm.py
	python generate_graphics_asm.py --output src/asm/graphics_auto.asm
	python generate_graphics_asm.py --category enemies

Author: FFMQ Disassembly Project
Date: 2025-11-02
"""

import sys
import json
from pathlib import Path
from typing import List, Dict, Optional
from collections import defaultdict


class GraphicsASMGenerator:
	"""Generates asar assembly files for rebuilt graphics."""

	def __init__(self, project_root: Path):
		"""
		Initialize the generator.

		Args:
			project_root: Root directory of the project
		"""
		self.project_root = project_root
		self.rebuilt_dir = project_root / 'data' / 'rebuilt'
		self.output_dir = project_root / 'src' / 'asm' / 'graphics'
		self.output_dir.mkdir(parents=True, exist_ok=True)

	def load_import_summary(self, category: str) -> Optional[Dict]:
		"""
		Load import summary for a category.

		Args:
			category: Category name (e.g., 'sprites', 'enemies')

		Returns:
			Import summary dict or None
		"""
		summary_path = self.rebuilt_dir / category / 'import_summary.json'

		if not summary_path.exists():
			return None

		with open(summary_path, 'r') as f:
			return json.load(f)

	def generate_sprite_includes(self, sprite_data: List[Dict]) -> str:
		"""
		Generate incbin statements for sprites.

		Args:
			sprite_data: List of sprite metadata

		Returns:
			Assembly code string
		"""
		lines = []
		lines.append("; Auto-generated sprite graphics includes")
		lines.append("; Generated by tools/generate_graphics_asm.py")
		lines.append("")

		# Group by ROM address
		by_address = defaultdict(list)
		for sprite in sprite_data:
			if sprite.get('rom_offset'):
				by_address[sprite['rom_offset']].append(sprite)

		# Sort by address
		for address in sorted(by_address.keys(), key=lambda x: int(x, 16) if isinstance(x, str) else x):
			sprites = by_address[address]

			# Convert address to proper format
			if isinstance(address, str):
				if address.startswith('0x'):
					addr_value = int(address, 16)
				else:
					addr_value = int(address, 16) if address.startswith('$') else int(address)
			else:
				addr_value = address

			lines.append(f"; Graphics at ${addr_value:06X}")

			for sprite in sprites:
				name = sprite['name']
				size = sprite['size_bytes']

				# Get relative path from project root
				bin_path = f"data/rebuilt/sprites/enemies/{name}.bin"

				lines.append(f"org ${addr_value:06X}")
				lines.append(f"\t; {name} - {size} bytes")
				lines.append(f'\tincbin "{bin_path}"')

				# Include palette if present
				if sprite.get('palette_offset'):
					pal_addr = sprite['palette_offset']
					if isinstance(pal_addr, str):
						if pal_addr.startswith('0x'):
							pal_value = int(pal_addr, 16)
						else:
							pal_value = int(pal_addr, 16) if pal_addr.startswith('$') else int(pal_addr)
					else:
						pal_value = pal_addr

					pal_path = f"data/rebuilt/sprites/enemies/{name}_palette.bin"
					lines.append(f"org ${pal_value:06X}")
					lines.append(f"\t; {name} palette - 16 bytes")
					lines.append(f'\tincbin "{pal_path}"')

				lines.append("")

		return '\n'.join(lines)

	def generate_category_asm(self, category: str) -> Optional[Path]:
		"""
		Generate ASM file for a category.

		Args:
			category: Category name

		Returns:
			Path to generated file or None
		"""
		print(f"  üìù Generating ASM for {category}...")

		summary = self.load_import_summary(category)

		if not summary:
			print(f"	‚ö†Ô∏è  No import summary found")
			return None

		sprites = summary.get('sprites', [])

		if not sprites:
			print(f"	‚ÑπÔ∏è  No sprites to include")
			return None

		# Generate ASM content
		asm_content = self.generate_sprite_includes(sprites)

		# Write to file
		output_path = self.output_dir / f"{category}_auto.asm"
		with open(output_path, 'w') as f:
			f.write(asm_content)

		print(f"	‚úì Generated {len(sprites)} sprite includes")
		print(f"	üìÑ {output_path}")

		return output_path

	def generate_master_include(self, generated_files: List[Path]) -> Path:
		"""
		Generate master include file that includes all category files.

		Args:
			generated_files: List of generated ASM files

		Returns:
			Path to master include file
		"""
		lines = []
		lines.append("; Auto-generated master graphics include file")
		lines.append("; Generated by tools/generate_graphics_asm.py")
		lines.append("; This file includes all rebuilt graphics into the ROM")
		lines.append("")
		lines.append("; DO NOT EDIT MANUALLY - This file is auto-generated")
		lines.append("; Regenerate with: python tools/generate_graphics_asm.py")
		lines.append("")

		for asm_file in sorted(generated_files):
			rel_path = asm_file.relative_to(self.project_root)
			# Use forward slashes for asar compatibility
			include_path = str(rel_path).replace('\\', '/')
			lines.append(f'incsrc "{include_path}"')

		lines.append("")

		master_path = self.output_dir / 'graphics_auto.asm'
		with open(master_path, 'w') as f:
			f.write('\n'.join(lines))

		return master_path

	def generate_all(self) -> bool:
		"""
		Generate all graphics ASM files.

		Returns:
			True if successful
		"""
		print("\nüî® Generating graphics ASM includes...")

		# Find all categories
		categories = []
		if self.rebuilt_dir.exists():
			for item in self.rebuilt_dir.iterdir():
				if item.is_dir() and (item / 'import_summary.json').exists():
					categories.append(item.name)

		if not categories:
			print("  ‚ö†Ô∏è  No rebuilt graphics found")
			return False

		print(f"  Found {len(categories)} categories: {', '.join(categories)}")

		# Generate ASM for each category
		generated_files = []

		for category in categories:
			asm_file = self.generate_category_asm(category)
			if asm_file:
				generated_files.append(asm_file)

		if not generated_files:
			print("  ‚ö†Ô∏è  No ASM files generated")
			return False

		# Generate master include
		master_file = self.generate_master_include(generated_files)

		print(f"\n‚úÖ Graphics ASM generation complete!")
		print(f"   Categories: {len(generated_files)}")
		print(f"   Master include: {master_file}")
		print(f"\n   Add to your main ASM file:")
		print(f'   incsrc "src/asm/graphics/graphics_auto.asm"')

		return True

	def validate_addresses(self) -> bool:
		"""
		Validate ROM addresses don't overlap.

		Returns:
			True if all valid
		"""
		print("\nüîç Validating ROM addresses...")

		# Collect all address ranges
		address_ranges = []

		for category_dir in self.rebuilt_dir.iterdir():
			if not category_dir.is_dir():
				continue

			summary = self.load_import_summary(category_dir.name)
			if not summary:
				continue

			for sprite in summary.get('sprites', []):
				if not sprite.get('rom_offset'):
					continue

				addr = sprite['rom_offset']
				if isinstance(addr, str):
					addr = int(addr, 16) if addr.startswith('0x') else int(addr, 16)

				size = sprite['size_bytes']

				address_ranges.append({
					'start': addr,
					'end': addr + size,
					'name': sprite['name'],
					'category': category_dir.name
				})

		# Sort by start address
		address_ranges.sort(key=lambda x: x['start'])

		# Check for overlaps
		overlaps = []
		for i in range(len(address_ranges) - 1):
			current = address_ranges[i]
			next_range = address_ranges[i + 1]

			if current['end'] > next_range['start']:
				overlaps.append((current, next_range))

		if overlaps:
			print(f"  ‚ùå Found {len(overlaps)} address overlaps:")
			for current, next_range in overlaps[:5]:  # Show first 5
				print(f"	 {current['name']} (${current['start']:06X}-${current['end']:06X})")
				print(f"	 overlaps with")
				print(f"	 {next_range['name']} (${next_range['start']:06X}-${next_range['end']:06X})")
			return False

		print(f"  ‚úì All {len(address_ranges)} address ranges valid (no overlaps)")
		return True


def main():
	"""Main function for command-line usage."""
	import argparse

	parser = argparse.ArgumentParser(
		description='Generate asar assembly includes for rebuilt graphics'
	)
	parser.add_argument('--project-root', type=Path, default=Path.cwd(),
						help='Project root directory')
	parser.add_argument('--category', type=str,
						help='Generate only for specific category')
	parser.add_argument('--validate', action='store_true',
						help='Validate address ranges')

	args = parser.parse_args()

	generator = GraphicsASMGenerator(args.project_root)

	# Validate if requested
	if args.validate:
		if not generator.validate_addresses():
			return 1

	# Generate ASM files
	if args.category:
		# Single category
		asm_file = generator.generate_category_asm(args.category)
		return 0 if asm_file else 1
	else:
		# All categories
		success = generator.generate_all()
		return 0 if success else 1


if __name__ == '__main__':
	sys.exit(main())
